"""Minimal Bot scaffold with plugin loader and language support.

This module provides a lightweight Bot class used during the Lua->Python
porting. It discovers plugins under `python_bot.plugins` and loads
language modules under `python_bot.lang` (auto-generated by scripts).
"""
import importlib
import pkgutil
import sys
from pathlib import Path
from types import ModuleType
from typing import Dict, List


class Bot:

    # ================= FUNCIONES SUGERIDAS (STUBS) =================
    async def send_critical_alert(self, chat_id, message):
        """Enviar alerta crítica a canal/grupo."""
        # TODO: Implementar lógica de envío
        pass

    async def send_daily_summary(self, chat_id):
        """Enviar resumen diario/semanal de actividad o logs."""
        # TODO: Implementar lógica de resumen
        pass

    async def list_active_users(self, chat_id):
        """Listar usuarios activos y sus permisos."""
        # TODO: Implementar lógica de listado
        pass

    async def audit_permission_changes(self):
        """Auditar cambios de permisos/accesos."""
        # TODO: Implementar lógica de auditoría
        pass

    async def report_service_status(self, chat_id):
        """Consultar y reportar estado de servicios externos."""
        # TODO: Implementar lógica de consulta y reporte
        pass

    async def restart_service(self, service_name):
        """Reiniciar servicio externo desde el bot."""
        # TODO: Implementar lógica de reinicio
        pass

    async def clean_temp_files(self):
        """Limpieza automática de archivos temporales/logs antiguos."""
        # TODO: Implementar lógica de limpieza
        pass

    async def update_dependencies(self):
        """Comprobar y actualizar dependencias del sistema/bot."""
        # TODO: Implementar lógica de actualización
        pass

    async def backup_config(self):
        """Hacer backup de configuraciones clave."""
        # TODO: Implementar lógica de backup
        pass

    async def restore_config(self):
        """Restaurar configuraciones clave."""
        # TODO: Implementar lógica de restauración
        pass

    async def analyze_logs_for_errors(self):
        """Analizar logs y detectar patrones de error frecuentes."""
        # TODO: Implementar lógica de análisis
        pass

    async def interactive_help(self, chat_id, user_id):
        """Ayuda interactiva según permisos del usuario."""
        # TODO: Implementar lógica de ayuda
        pass

    async def suggest_commands(self, chat_id, user_input):
        """Sugerir comandos/autocompletar."""
        # TODO: Implementar lógica de sugerencia
        pass

    async def show_bot_stats(self, chat_id):
        """Mostrar estadísticas de uso del bot."""
        # TODO: Implementar lógica de estadísticas
        pass

    async def system_resource_monitor(self, chat_id):
        """Monitor de recursos del sistema accesible desde el bot."""
        # TODO: Implementar lógica de monitorización
        pass

    # ================= INTEGRACIÓN DE COMANDOS =================
    def register_default_commands(self):
        """Registra comandos básicos para las funciones sugeridas."""
        self.register_command('alerta_critica', self.cmd_alerta_critica, 'Enviar alerta crítica')
        self.register_command('resumen_diario', self.cmd_resumen_diario, 'Solicitar resumen diario')
        self.register_command('usuarios_activos', self.cmd_usuarios_activos, 'Listar usuarios activos')
        self.register_command('estado_servicios', self.cmd_estado_servicios, 'Consultar estado de servicios')
        self.register_command('limpiar_temp', self.cmd_limpiar_temp, 'Limpiar archivos temporales')
        self.register_command('backup_config', self.cmd_backup_config, 'Backup de configuración')
        self.register_command('ayuda_interactiva', self.cmd_ayuda_interactiva, 'Ayuda interactiva')
        self.register_command('estadisticas_bot', self.cmd_estadisticas_bot, 'Estadísticas del bot')
        self.register_command('monitor_sistema', self.cmd_monitor_sistema, 'Monitor de sistema')

    async def cmd_alerta_critica(self, update, context):
        await self.send_critical_alert(update.effective_chat.id, "¡Alerta crítica enviada!")
        await update.message.reply_text("Alerta crítica enviada.")

    async def cmd_resumen_diario(self, update, context):
        await self.send_daily_summary(update.effective_chat.id)
        await update.message.reply_text("Resumen diario solicitado.")

    async def cmd_usuarios_activos(self, update, context):
        await self.list_active_users(update.effective_chat.id)
        await update.message.reply_text("Usuarios activos listados.")

    async def cmd_estado_servicios(self, update, context):
        await self.report_service_status(update.effective_chat.id)
        await update.message.reply_text("Estado de servicios consultado.")

    async def cmd_limpiar_temp(self, update, context):
        await self.clean_temp_files()
        await update.message.reply_text("Archivos temporales limpiados.")

    async def cmd_backup_config(self, update, context):
        await self.backup_config()
        await update.message.reply_text("Backup de configuración realizado.")

    async def cmd_ayuda_interactiva(self, update, context):
        await self.interactive_help(update.effective_chat.id, update.effective_user.id)
        await update.message.reply_text("Ayuda interactiva mostrada.")

    async def cmd_estadisticas_bot(self, update, context):
        await self.show_bot_stats(update.effective_chat.id)
        await update.message.reply_text("Estadísticas del bot mostradas.")

    async def cmd_monitor_sistema(self, update, context):
        await self.system_resource_monitor(update.effective_chat.id)
        await update.message.reply_text("Monitor de sistema ejecutado.")

    # ================= INTEGRACIÓN WEB (ESQUEMA BÁSICO) =================
    # Ejemplo: usar Flask/FastAPI para exponer endpoints que llamen a estas funciones
    # from fastapi import FastAPI, Request
    # app = FastAPI()
    # @app.post("/api/alerta_critica")
    # async def api_alerta_critica(request: Request):
    #     data = await request.json()
    #     await self.send_critical_alert(data['chat_id'], data['message'])
    #     return {"status": "ok"}
    # ...agrega más endpoints según funciones...
        async def leave_group_by_id(self, group_id):
            # This method should use the Telegram API to leave the group by ID
            # You may need to adapt this to your bot framework
            try:
                if hasattr(self, 'telegram_bot'):
                    await self.telegram_bot.leave_chat(int(group_id))
                elif hasattr(self, 'updater') and hasattr(self.updater, 'bot'):
                    await self.updater.bot.leave_chat(int(group_id))
                # Add other frameworks as needed
            except Exception as e:
                print(f'Error leaving group {group_id}: {e}')
    def __init__(self):
        self.plugins: Dict[str, ModuleType] = {}
        self.lang_modules: Dict[str, ModuleType] = {}
        # command_registry maps command name (no leading slash) to dict with
        # keys: 'handler' (callable), 'description' (str), 'plugin' (str)
        self.command_registry: Dict[str, Dict] = {}
        # message_handlers: list of dicts with keys: 'filter' (str), 'handler' (callable), 'plugin' (str)
        self.message_handlers: List[Dict] = []
        # inline query handlers: list of dicts with keys: 'handler' (callable), 'plugin' (str)
        self.inline_handlers: List[Dict] = []
        # plugin file mtimes for live-reload
        self._plugin_mtimes: Dict[str, float] = {}
        self._watcher_thread = None

    def start(self):
        print('Starting python_bot...')
        # load default english language to ensure get_text works
        self.load_lang('en')
        self.load_plugins()
        print(f'Loaded plugins: {list(self.plugins.keys())}')
        # Registrar comandos sugeridos automáticamente
        self.register_default_commands()

    def load_plugins(self):
        """Discover and import plugins from package `python_bot.plugins`.

        If a plugin module exposes a `setup(bot)` callable it will be invoked
        with the current Bot instance so plugins can register callbacks.
        """
        package_name = 'python_bot.plugins'
        try:
            pkg = importlib.import_module(package_name)
        except Exception:
            print(f'Package {package_name} not available, skipping plugin load')
            return

        if not hasattr(pkg, '__path__'):
            return

        for finder, name, ispkg in pkgutil.iter_modules(pkg.__path__):
            try:
                modname = f'{package_name}.{name}'
                mod = importlib.import_module(modname)
                self.plugins[name] = mod
                # call optional setup
                setup_fn = getattr(mod, 'setup', None)
                if callable(setup_fn):
                    try:
                        setup_fn(self)
                    except Exception as e:
                        print(f'Plugin {name} setup() failed: {e}')
                # record mtime for live reload
                try:
                    path = Path(mod.__file__)
                    self._plugin_mtimes[name] = path.stat().st_mtime
                except Exception:
                    pass
            except Exception as e:
                print(f'Failed to load plugin {name}: {e}')

        # start watcher thread after initial load
        try:
            self._start_watcher()
        except Exception:
            pass

    def _start_watcher(self):
        import threading, time
        if self._watcher_thread is not None:
            return
        def _watch():
            while True:
                try:
                    self._scan_plugins_for_changes()
                except Exception:
                    pass
                time.sleep(1.0)
        t = threading.Thread(target=_watch, daemon=True)
        t.start()
        self._watcher_thread = t

    def _scan_plugins_for_changes(self):
        # check plugin files under python_bot.plugins and reload if mtime changed
        package_name = 'python_bot.plugins'
        try:
            pkg = importlib.import_module(package_name)
        except Exception:
            return
        if not hasattr(pkg, '__path__'):
            return
        for finder, name, ispkg in pkgutil.iter_modules(pkg.__path__):
            try:
                mod = self.plugins.get(name)
                modname = f'{package_name}.{name}'
                # determine file path
                spec = None
                try:
                    spec = importlib.util.find_spec(modname)
                except Exception:
                    spec = None
                filepath = None
                if spec and getattr(spec, 'origin', None):
                    filepath = spec.origin
                elif mod is not None and getattr(mod, '__file__', None):
                    filepath = mod.__file__
                if not filepath:
                    continue
                try:
                    mtime = Path(filepath).stat().st_mtime
                except Exception:
                    continue
                prev = self._plugin_mtimes.get(name)
                if prev is None:
                    self._plugin_mtimes[name] = mtime
                    continue
                if mtime != prev:
                    print(f"[watcher] Detected change in plugin {name}, reloading...")
                    self._plugin_mtimes[name] = mtime
                    try:
                        self.reload_plugin(name)
                    except Exception as e:
                        print(f"[watcher] reload of {name} failed: {e}")
            except Exception:
                pass

    def reload_plugin(self, name: str):
        """Unload and reload a plugin by name. This will remove any registered
        commands/handlers associated with the plugin and re-run its `setup(bot)`.
        """
        # remove registrations for this plugin
        try:
            # commands
            to_remove = [c for c, md in list(self.command_registry.items()) if md.get('plugin') == name]
            for c in to_remove:
                del self.command_registry[c]
            # message handlers
            self.message_handlers = [mh for mh in self.message_handlers if mh.get('plugin') != name]
            # inline handlers
            self.inline_handlers = [ih for ih in self.inline_handlers if ih.get('plugin') != name]
        except Exception:
            pass
        # reload module
        modname = f'python_bot.plugins.{name}'
        try:
            if modname in sys.modules:
                m = sys.modules[modname]
                importlib.reload(m)
                self.plugins[name] = m
            else:
                m = importlib.import_module(modname)
                self.plugins[name] = m
            # call setup
            setup_fn = getattr(self.plugins[name], 'setup', None)
            if callable(setup_fn):
                try:
                    setup_fn(self)
                except Exception as e:
                    print(f'Plugin {name} setup() after reload failed: {e}')
        except Exception as e:
            print(f'Failed to reload plugin {name}: {e}')

    # Language helpers
    def load_lang(self, code: str) -> ModuleType:
        """Import and cache language module `python_bot.lang.<code>`.

        Returns the module or raises ImportError if not found.
        """
        code = (code or 'en').lower()
        if code in self.lang_modules:
            return self.lang_modules[code]
        mod_name = f'python_bot.lang.{code}'
        try:
            mod = importlib.import_module(mod_name)
            self.lang_modules[code] = mod
            return mod
        except Exception:
            # fallback: try english/english.py or en.py
            for fallback in ('en', 'english'):
                try:
                    mod = importlib.import_module(f'python_bot.lang.{fallback}')
                    self.lang_modules[code] = mod
                    return mod
                except Exception:
                    continue
            raise

    def get_text(self, key: str, lang: str = 'en') -> str:
        """Lookup translated text for `key` in language `lang`.

        Uses language module's `get_text` if available, otherwise returns a
        simple fallback string.
        """
        try:
            mod = self.load_lang(lang)
            get_fn = getattr(mod, 'get_text', None)
            if callable(get_fn):
                return get_fn(key, None) or f'[{key}]'
            # else try direct dict
            lang_dict = getattr(mod, 'LANG', None) or getattr(mod, 'WEB_STRINGS', None)
            if isinstance(lang_dict, dict):
                return lang_dict.get(key, f'[{key}]')
            return f'[{key}]'
        except Exception:
            return f'[{key}]'

    # Command registration for Telegram
    def register_command(self, name: str, handler, description: str = '', plugin: str = ''):
        """Register a Telegram command handler.

        `name` should be without leading slash. `handler` will be called with
        the arguments (update, context) by the runner. Plugins should call
        this in their `setup(bot)` function.
        """
        n = (name or '').lstrip('/').lower()
        if not n:
            raise ValueError('command name required')
        self.command_registry[n] = {'handler': handler, 'description': description or '', 'plugin': plugin}

    def get_registered_commands(self):
        """Return mapping of command -> metadata."""
        return dict(self.command_registry)

    def register_message_handler(self, filter_type: str, handler, plugin: str = ''):
        """Register a message handler for a given filter type.

        `filter_type` is a short string: 'document', 'video', 'audio', 'photo', 'text', or a pipe-separated combination.
        The runner will map this to PTB filters when building handlers.
        """
        if not filter_type or not handler:
            raise ValueError('filter_type and handler required')
        self.message_handlers.append({'filter': filter_type, 'handler': handler, 'plugin': plugin})

    def get_registered_message_handlers(self):
        return list(self.message_handlers)

    def register_inline_handler(self, handler, plugin: str = ''):
        """Register an inline query handler callable.

        The handler will be called with the usual (update, context) signature
        and is responsible for answering the inline query via
        `update.inline_query.answer(results)`.
        """
        if not handler:
            raise ValueError('handler required')
        self.inline_handlers.append({'handler': handler, 'plugin': plugin})

    def get_registered_inline_handlers(self):
        return list(self.inline_handlers)
