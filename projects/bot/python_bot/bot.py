"""Minimal Bot scaffold with plugin loader and language support.

This module provides a lightweight Bot class used during the Lua->Python
porting. It discovers plugins under `python_bot.plugins` and loads
language modules under `python_bot.lang` (auto-generated by scripts).
"""
import importlib
import pkgutil
import sys
from pathlib import Path
from types import ModuleType
from typing import Dict, List


class Bot:
    def __init__(self):
        self.plugins: Dict[str, ModuleType] = {}
        self.lang_modules: Dict[str, ModuleType] = {}
        # command_registry maps command name (no leading slash) to dict with
        # keys: 'handler' (callable), 'description' (str), 'plugin' (str)
        self.command_registry: Dict[str, Dict] = {}
        # message_handlers: list of dicts with keys: 'filter' (str), 'handler' (callable), 'plugin' (str)
        self.message_handlers: List[Dict] = []
        # inline query handlers: list of dicts with keys: 'handler' (callable), 'plugin' (str)
        self.inline_handlers: List[Dict] = []
        # plugin file mtimes for live-reload
        self._plugin_mtimes: Dict[str, float] = {}
        self._watcher_thread = None

    def start(self):
        print('Starting python_bot...')
        # load default english language to ensure get_text works
        self.load_lang('en')
        self.load_plugins()
        print(f'Loaded plugins: {list(self.plugins.keys())}')

    def load_plugins(self):
        """Discover and import plugins from package `python_bot.plugins`.

        If a plugin module exposes a `setup(bot)` callable it will be invoked
        with the current Bot instance so plugins can register callbacks.
        """
        package_name = 'python_bot.plugins'
        try:
            pkg = importlib.import_module(package_name)
        except Exception:
            print(f'Package {package_name} not available, skipping plugin load')
            return

        if not hasattr(pkg, '__path__'):
            return

        for finder, name, ispkg in pkgutil.iter_modules(pkg.__path__):
            try:
                modname = f'{package_name}.{name}'
                mod = importlib.import_module(modname)
                self.plugins[name] = mod
                # call optional setup
                setup_fn = getattr(mod, 'setup', None)
                if callable(setup_fn):
                    try:
                        setup_fn(self)
                    except Exception as e:
                        print(f'Plugin {name} setup() failed: {e}')
                # record mtime for live reload
                try:
                    path = Path(mod.__file__)
                    self._plugin_mtimes[name] = path.stat().st_mtime
                except Exception:
                    pass
            except Exception as e:
                print(f'Failed to load plugin {name}: {e}')

        # start watcher thread after initial load
        try:
            self._start_watcher()
        except Exception:
            pass

    def _start_watcher(self):
        import threading, time
        if self._watcher_thread is not None:
            return
        def _watch():
            while True:
                try:
                    self._scan_plugins_for_changes()
                except Exception:
                    pass
                time.sleep(1.0)
        t = threading.Thread(target=_watch, daemon=True)
        t.start()
        self._watcher_thread = t

    def _scan_plugins_for_changes(self):
        # check plugin files under python_bot.plugins and reload if mtime changed
        package_name = 'python_bot.plugins'
        try:
            pkg = importlib.import_module(package_name)
        except Exception:
            return
        if not hasattr(pkg, '__path__'):
            return
        for finder, name, ispkg in pkgutil.iter_modules(pkg.__path__):
            try:
                mod = self.plugins.get(name)
                modname = f'{package_name}.{name}'
                # determine file path
                spec = None
                try:
                    spec = importlib.util.find_spec(modname)
                except Exception:
                    spec = None
                filepath = None
                if spec and getattr(spec, 'origin', None):
                    filepath = spec.origin
                elif mod is not None and getattr(mod, '__file__', None):
                    filepath = mod.__file__
                if not filepath:
                    continue
                try:
                    mtime = Path(filepath).stat().st_mtime
                except Exception:
                    continue
                prev = self._plugin_mtimes.get(name)
                if prev is None:
                    self._plugin_mtimes[name] = mtime
                    continue
                if mtime != prev:
                    print(f"[watcher] Detected change in plugin {name}, reloading...")
                    self._plugin_mtimes[name] = mtime
                    try:
                        self.reload_plugin(name)
                    except Exception as e:
                        print(f"[watcher] reload of {name} failed: {e}")
            except Exception:
                pass

    def reload_plugin(self, name: str):
        """Unload and reload a plugin by name. This will remove any registered
        commands/handlers associated with the plugin and re-run its `setup(bot)`.
        """
        # remove registrations for this plugin
        try:
            # commands
            to_remove = [c for c, md in list(self.command_registry.items()) if md.get('plugin') == name]
            for c in to_remove:
                del self.command_registry[c]
            # message handlers
            self.message_handlers = [mh for mh in self.message_handlers if mh.get('plugin') != name]
            # inline handlers
            self.inline_handlers = [ih for ih in self.inline_handlers if ih.get('plugin') != name]
        except Exception:
            pass
        # reload module
        modname = f'python_bot.plugins.{name}'
        try:
            if modname in sys.modules:
                m = sys.modules[modname]
                importlib.reload(m)
                self.plugins[name] = m
            else:
                m = importlib.import_module(modname)
                self.plugins[name] = m
            # call setup
            setup_fn = getattr(self.plugins[name], 'setup', None)
            if callable(setup_fn):
                try:
                    setup_fn(self)
                except Exception as e:
                    print(f'Plugin {name} setup() after reload failed: {e}')
        except Exception as e:
            print(f'Failed to reload plugin {name}: {e}')

    # Language helpers
    def load_lang(self, code: str) -> ModuleType:
        """Import and cache language module `python_bot.lang.<code>`.

        Returns the module or raises ImportError if not found.
        """
        code = (code or 'en').lower()
        if code in self.lang_modules:
            return self.lang_modules[code]
        mod_name = f'python_bot.lang.{code}'
        try:
            mod = importlib.import_module(mod_name)
            self.lang_modules[code] = mod
            return mod
        except Exception:
            # fallback: try english/english.py or en.py
            for fallback in ('en', 'english'):
                try:
                    mod = importlib.import_module(f'python_bot.lang.{fallback}')
                    self.lang_modules[code] = mod
                    return mod
                except Exception:
                    continue
            raise

    def get_text(self, key: str, lang: str = 'en') -> str:
        """Lookup translated text for `key` in language `lang`.

        Uses language module's `get_text` if available, otherwise returns a
        simple fallback string.
        """
        try:
            mod = self.load_lang(lang)
            get_fn = getattr(mod, 'get_text', None)
            if callable(get_fn):
                return get_fn(key, None) or f'[{key}]'
            # else try direct dict
            lang_dict = getattr(mod, 'LANG', None) or getattr(mod, 'WEB_STRINGS', None)
            if isinstance(lang_dict, dict):
                return lang_dict.get(key, f'[{key}]')
            return f'[{key}]'
        except Exception:
            return f'[{key}]'

    # Command registration for Telegram
    def register_command(self, name: str, handler, description: str = '', plugin: str = ''):
        """Register a Telegram command handler.

        `name` should be without leading slash. `handler` will be called with
        the arguments (update, context) by the runner. Plugins should call
        this in their `setup(bot)` function.
        """
        n = (name or '').lstrip('/').lower()
        if not n:
            raise ValueError('command name required')
        self.command_registry[n] = {'handler': handler, 'description': description or '', 'plugin': plugin}

    def get_registered_commands(self):
        """Return mapping of command -> metadata."""
        return dict(self.command_registry)

    def register_message_handler(self, filter_type: str, handler, plugin: str = ''):
        """Register a message handler for a given filter type.

        `filter_type` is a short string: 'document', 'video', 'audio', 'photo', 'text', or a pipe-separated combination.
        The runner will map this to PTB filters when building handlers.
        """
        if not filter_type or not handler:
            raise ValueError('filter_type and handler required')
        self.message_handlers.append({'filter': filter_type, 'handler': handler, 'plugin': plugin})

    def get_registered_message_handlers(self):
        return list(self.message_handlers)

    def register_inline_handler(self, handler, plugin: str = ''):
        """Register an inline query handler callable.

        The handler will be called with the usual (update, context) signature
        and is responsible for answering the inline query via
        `update.inline_query.answer(results)`.
        """
        if not handler:
            raise ValueError('handler required')
        self.inline_handlers.append({'handler': handler, 'plugin': plugin})

    def get_registered_inline_handlers(self):
        return list(self.inline_handlers)
