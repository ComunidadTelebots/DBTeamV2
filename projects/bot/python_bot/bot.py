"""Minimal Bot scaffold with plugin loader and language support.

This module provides a lightweight Bot class used during the Lua->Python
porting. It discovers plugins under `python_bot.plugins` and loads
language modules under `python_bot.lang` (auto-generated by scripts).
"""
import importlib
import pkgutil
import sys
from pathlib import Path
from types import ModuleType
from typing import Dict


class Bot:
    def __init__(self):
        self.plugins: Dict[str, ModuleType] = {}
        self.lang_modules: Dict[str, ModuleType] = {}
        # command_registry maps command name (no leading slash) to dict with
        # keys: 'handler' (callable), 'description' (str), 'plugin' (str)
        self.command_registry: Dict[str, Dict] = {}
        # message_handlers: list of dicts with keys: 'filter' (str), 'handler' (callable), 'plugin' (str)
        self.message_handlers: List[Dict] = []

    def start(self):
        print('Starting python_bot...')
        # load default english language to ensure get_text works
        self.load_lang('en')
        self.load_plugins()
        print(f'Loaded plugins: {list(self.plugins.keys())}')

    def load_plugins(self):
        """Discover and import plugins from package `python_bot.plugins`.

        If a plugin module exposes a `setup(bot)` callable it will be invoked
        with the current Bot instance so plugins can register callbacks.
        """
        package_name = 'python_bot.plugins'
        try:
            pkg = importlib.import_module(package_name)
        except Exception:
            print(f'Package {package_name} not available, skipping plugin load')
            return

        if not hasattr(pkg, '__path__'):
            return

        for finder, name, ispkg in pkgutil.iter_modules(pkg.__path__):
            try:
                mod = importlib.import_module(f'{package_name}.{name}')
                self.plugins[name] = mod
                # call optional setup
                setup_fn = getattr(mod, 'setup', None)
                if callable(setup_fn):
                    try:
                        setup_fn(self)
                    except Exception as e:
                        print(f'Plugin {name} setup() failed: {e}')
            except Exception as e:
                print(f'Failed to load plugin {name}: {e}')

    # Language helpers
    def load_lang(self, code: str) -> ModuleType:
        """Import and cache language module `python_bot.lang.<code>`.

        Returns the module or raises ImportError if not found.
        """
        code = (code or 'en').lower()
        if code in self.lang_modules:
            return self.lang_modules[code]
        mod_name = f'python_bot.lang.{code}'
        try:
            mod = importlib.import_module(mod_name)
            self.lang_modules[code] = mod
            return mod
        except Exception:
            # fallback: try english/english.py or en.py
            for fallback in ('en', 'english'):
                try:
                    mod = importlib.import_module(f'python_bot.lang.{fallback}')
                    self.lang_modules[code] = mod
                    return mod
                except Exception:
                    continue
            raise

    def get_text(self, key: str, lang: str = 'en') -> str:
        """Lookup translated text for `key` in language `lang`.

        Uses language module's `get_text` if available, otherwise returns a
        simple fallback string.
        """
        try:
            mod = self.load_lang(lang)
            get_fn = getattr(mod, 'get_text', None)
            if callable(get_fn):
                return get_fn(key, None) or f'[{key}]'
            # else try direct dict
            lang_dict = getattr(mod, 'LANG', None) or getattr(mod, 'WEB_STRINGS', None)
            if isinstance(lang_dict, dict):
                return lang_dict.get(key, f'[{key}]')
            return f'[{key}]'
        except Exception:
            return f'[{key}]'

    # Command registration for Telegram
    def register_command(self, name: str, handler, description: str = '', plugin: str = ''):
        """Register a Telegram command handler.

        `name` should be without leading slash. `handler` will be called with
        the arguments (update, context) by the runner. Plugins should call
        this in their `setup(bot)` function.
        """
        n = (name or '').lstrip('/').lower()
        if not n:
            raise ValueError('command name required')
        self.command_registry[n] = {'handler': handler, 'description': description or '', 'plugin': plugin}

    def get_registered_commands(self):
        """Return mapping of command -> metadata."""
        return dict(self.command_registry)

    def register_message_handler(self, filter_type: str, handler, plugin: str = ''):
        """Register a message handler for a given filter type.

        `filter_type` is a short string: 'document', 'video', 'audio', 'photo', 'text', or a pipe-separated combination.
        The runner will map this to PTB filters when building handlers.
        """
        if not filter_type or not handler:
            raise ValueError('filter_type and handler required')
        self.message_handlers.append({'filter': filter_type, 'handler': handler, 'plugin': plugin})

    def get_registered_message_handlers(self):
        return list(self.message_handlers)
